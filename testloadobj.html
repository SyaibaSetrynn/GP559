<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test Load OBJ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #1a1a1a;
            font-family: Arial, sans-serif;
        }
        
        #container {
            position: relative;
        }
        
        canvas {
            display: block;
            border: 2px solid #333;
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="canvas" width="1280" height="720"></canvas>
    </div>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://esm.sh/three@0.161.0",
                "three/addons/": "https://esm.sh/three@0.161.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
        import { MTLLoader } from 'three/addons/loaders/MTLLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        
        const canvas = document.getElementById('canvas');
        const width = canvas.width;
        const height = canvas.height;
        
        // 创建场景
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        
        // 创建相机
        const aspect = width / height;
        const camera = new THREE.PerspectiveCamera(45, aspect, 0.1, 1000);
        camera.position.set(0, 40, 0);
        camera.lookAt(0, 0, 0);
        
        // 创建渲染器
        const renderer = new THREE.WebGLRenderer({ 
            canvas: canvas,
            antialias: true 
        });
        renderer.setSize(width, height);
        renderer.setPixelRatio(window.devicePixelRatio);
        
        // 添加轨道控制器（允许鼠标拖动改变视角）
        const controls = new OrbitControls(camera, canvas);
        controls.target.set(0, 0, 0); // 控制目标点
        controls.enableDamping = true; // 启用阻尼，使旋转更平滑
        controls.dampingFactor = 0.05;
        controls.minDistance = 10; // 最小距离
        controls.maxDistance = 200; // 最大距离
        controls.update();
        
        // 渲染循环函数
        let animationId = null;
        let lastCameraLogTime = 0;
        
        function animate() {
            animationId = requestAnimationFrame(animate);
            controls.update(); // 更新控制器
            renderer.render(scene, camera);
            
            // 每2秒打印一次相机位置和lookAt
            const now = Date.now();
            if (now - lastCameraLogTime >= 2000) {
                lastCameraLogTime = now;
                const pos = camera.position;
                const target = controls.target; // OrbitControls的目标点就是lookAt点
                console.log(`Camera Position: (${pos.x.toFixed(2)}, ${pos.y.toFixed(2)}, ${pos.z.toFixed(2)})`);
                console.log(`Looking At: (${target.x.toFixed(2)}, ${target.y.toFixed(2)}, ${target.z.toFixed(2)})`);
            }
        }
        
        // 添加灯光
        // 环境光
        const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
        scene.add(ambientLight);
        
        // 方向光
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
        directionalLight.position.set(10, 10, 10);
        scene.add(directionalLight);
        
        // 点光源
        const pointLight = new THREE.PointLight(0xffffff, 1.0);
        pointLight.position.set(0, 20, 0);
        scene.add(pointLight);
        
        console.log('Scene initialized');
        
        // 不再创建测试模型
        
        // 加载模型
        async function loadModel() {
            try {
                const modelName = 'Terrain1Prev';
                
                // 加载 MTL 材质
                const mtlLoader = new MTLLoader();
                mtlLoader.setPath('Objects/');
                const materials = await new Promise((resolve, reject) => {
                    mtlLoader.load(
                        `${modelName}.mtl`,
                        (materials) => {
                            console.log('MTL loaded', materials);
                            materials.preload();
                            
                            // 修复黑色材质问题：遍历所有材质并设置颜色
                            materials.materials = Object.keys(materials.materials).reduce((acc, key) => {
                                const mat = materials.materials[key];
                                // 如果材质是黑色，改为白色或灰色
                                if (mat.color && mat.color.r === 0 && mat.color.g === 0 && mat.color.b === 0) {
                                    mat.color.setHex(0x888888); // 设置为灰色
                                }
                                acc[key] = mat;
                                return acc;
                            }, {});
                            
                            resolve(materials);
                        },
                        undefined,
                        reject
                    );
                });
                
                // 加载 OBJ 模型
                const objLoader = new OBJLoader();
                objLoader.setMaterials(materials);
                objLoader.setPath('Objects/');
                const model = await new Promise((resolve, reject) => {
                    objLoader.load(
                        `${modelName}.obj`,
                        (object) => {
                            console.log('OBJ loaded', object);
                            console.log('Number of children:', object.children.length);
                            
                            // 函数：删除经过y轴的face（定义在traverse之前）
                            function removeFacesCrossingYAxis(mesh) {
                                const geometry = mesh.geometry;
                                if (!geometry || !geometry.attributes.position) {
                                    return;
                                }
                                
                                const positions = geometry.attributes.position;
                                const indices = geometry.index;
                                
                                if (!indices) {
                                    console.warn('Geometry has no index, cannot remove faces');
                                    return;
                                }
                                
                                // 找出所有经过y轴（y坐标接近某个值）的face
                                const facesToRemove = new Set();
                                const yThreshold = 1.0; // y坐标阈值，接近这个值的面（可能是盖子）
                                const sizeThreshold = 5.0; // 大小阈值，大的面更可能是盖子
                                
                                for (let i = 0; i < indices.count; i += 3) {
                                    const i1 = indices.getX(i);
                                    const i2 = indices.getX(i + 1);
                                    const i3 = indices.getX(i + 2);
                                    
                                    const y1 = positions.getY(i1);
                                    const y2 = positions.getY(i2);
                                    const y3 = positions.getY(i3);
                                    
                                    // 检查face是否接近某个y值（可能是盖子）
                                    const avgY = (y1 + y2 + y3) / 3;
                                    const yRange = Math.max(y1, y2, y3) - Math.min(y1, y2, y3);
                                    
                                    // 如果face的y坐标接近某个值，且y范围很小（说明是水平面）
                                    if (Math.abs(avgY) < yThreshold && yRange < 0.5) {
                                        // 进一步检查：如果face很大（覆盖范围大），更可能是盖子
                                        const x1 = positions.getX(i1);
                                        const x2 = positions.getX(i2);
                                        const x3 = positions.getX(i3);
                                        const z1 = positions.getZ(i1);
                                        const z2 = positions.getZ(i2);
                                        const z3 = positions.getZ(i3);
                                        
                                        const xRange = Math.max(x1, x2, x3) - Math.min(x1, x2, x3);
                                        const zRange = Math.max(z1, z2, z3) - Math.min(z1, z2, z3);
                                        
                                        // 如果face覆盖范围很大（可能是盖子），标记为删除
                                        if (xRange > sizeThreshold || zRange > sizeThreshold) {
                                            facesToRemove.add(i);
                                            facesToRemove.add(i + 1);
                                            facesToRemove.add(i + 2);
                                            console.log(`Found large face at y=${avgY.toFixed(2)}, size: x=${xRange.toFixed(2)}, z=${zRange.toFixed(2)}`);
                                        }
                                    }
                                }
                                    
                                if (facesToRemove.size > 0) {
                                    console.log(`Removing ${facesToRemove.size / 3} faces from Terrain (${facesToRemove.size} indices)`);
                                    
                                    // 创建新的索引数组，排除要删除的face
                                    const newIndices = [];
                                    for (let i = 0; i < indices.count; i += 3) {
                                        if (!facesToRemove.has(i)) {
                                            newIndices.push(indices.getX(i));
                                            newIndices.push(indices.getX(i + 1));
                                            newIndices.push(indices.getX(i + 2));
                                        }
                                    }
                                    
                                    // 更新几何体的索引
                                    geometry.setIndex(newIndices);
                                    geometry.computeVertexNormals(); // 重新计算法线
                                    console.log(`Terrain geometry updated: ${newIndices.length / 3} faces remaining (removed ${facesToRemove.size / 3} faces)`);
                                } else {
                                    console.log('No faces found crossing y-axis in Terrain');
                                }
                            }
                            
                            // 遍历所有子对象，打印信息并修复材质
                            let meshCount = 0;
                            let totalVertices = 0;
                            
                            object.traverse((child) => {
                                if (child.isMesh) {
                                    meshCount++;
                                    const vertexCount = child.geometry ? child.geometry.attributes.position.count : 0;
                                    totalVertices += vertexCount;
                                    
                                    const meshName = child.name || 'unnamed';
                                    console.log(`Mesh ${meshCount} [${meshName}]:`, {
                                        vertices: vertexCount,
                                        material: child.material ? (Array.isArray(child.material) ? 'array' : child.material.type) : 'none'
                                    });
                                    
                                    // 如果是Terrain组，检查并删除经过y轴的face
                                    if (meshName.includes('Terrain') || child.parent?.name?.includes('Terrain')) {
                                        console.log(`Processing Terrain mesh, removing faces that cross y-axis...`);
                                        removeFacesCrossingYAxis(child);
                                    }
                                    
                                    // 修复材质 - 确保所有mesh都有可见的材质
                                    if (child.material) {
                                        // 如果是黑色材质，替换为可见的材质
                                        if (Array.isArray(child.material)) {
                                            child.material = child.material.map(mat => {
                                                if (!mat) {
                                                    return new THREE.MeshStandardMaterial({ color: 0x888888 });
                                                }
                                                if (mat.color && mat.color.r === 0 && mat.color.g === 0 && mat.color.b === 0) {
                                                    return new THREE.MeshStandardMaterial({ color: 0x888888 });
                                                }
                                                // 确保材质是可见的
                                                if (mat.opacity === 0 || mat.visible === false) {
                                                    mat.opacity = 1;
                                                    mat.transparent = false;
                                                    mat.visible = true;
                                                }
                                                return mat;
                                            });
                                        } else {
                                            if (child.material.color && child.material.color.r === 0 && child.material.color.g === 0 && child.material.color.b === 0) {
                                                child.material = new THREE.MeshStandardMaterial({ color: 0x888888 });
                                            }
                                            // 确保材质是可见的
                                            if (child.material.opacity === 0 || child.material.visible === false) {
                                                child.material.opacity = 1;
                                                child.material.transparent = false;
                                                child.material.visible = true;
                                            }
                                        }
                                    } else {
                                        // 如果没有材质，添加默认材质
                                        child.material = new THREE.MeshStandardMaterial({ color: 0x888888 });
                                    }
                                    
                                    // 确保mesh是可见的
                                    child.visible = true;
                                }
                            });
                            
                            console.log(`Total meshes found: ${meshCount}, Total vertices: ${totalVertices}`);
                            
                            // 打印所有组的名称
                            console.log('All groups in model:');
                            object.traverse((child) => {
                                if (child.name) {
                                    console.log(`  - ${child.name}`);
                                }
                            });
                            
                            resolve(object);
                        },
                        undefined,
                        reject
                    );
                });
                
                // 计算模型边界框，用于居中
                const box = new THREE.Box3().setFromObject(model);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                
                console.log('Model center:', center);
                console.log('Model size:', size);
                
                // 居中模型
                model.position.x = -center.x;
                model.position.y = -center.y;
                model.position.z = -center.z;
                
                // 沿 y 轴顺时针旋转 30 度
                model.rotation.y = -Math.PI / 6;
                
                // 添加到场景
                scene.add(model);
                
                console.log('Model added to scene');
                
                // 开始渲染循环（如果还没有开始）
                if (!animationId) {
                    animate();
                }
                
            } catch (error) {
                console.error('Failed to load model:', error);
            }
        }
        
        // 开始加载模型
        loadModel();
        
        // 开始渲染循环
        if (!animationId) {
            animate();
        }
    </script>
</body>
</html>

