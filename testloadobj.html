<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test Load OBJ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #1a1a1a;
            font-family: Arial, sans-serif;
        }
        
        #container {
            position: relative;
        }
        
        canvas {
            display: block;
            border: 2px solid #333;
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="canvas" width="1280" height="720"></canvas>
    </div>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://esm.sh/three@0.161.0",
                "three/addons/": "https://esm.sh/three@0.161.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
        import { MTLLoader } from 'three/addons/loaders/MTLLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        
        const canvas = document.getElementById('canvas');
        const width = canvas.width;
        const height = canvas.height;
        
        // 创建场景
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        
        // 创建相机
        const aspect = width / height;
        const camera = new THREE.PerspectiveCamera(45, aspect, 0.1, 1000);
        camera.position.set(0, 40, 0);
        camera.lookAt(0, 0, 0);
        
        // 创建渲染器
        const renderer = new THREE.WebGLRenderer({ 
            canvas: canvas,
            antialias: true 
        });
        renderer.setSize(width, height);
        renderer.setPixelRatio(window.devicePixelRatio);
        
        // 添加轨道控制器（允许鼠标拖动改变视角）
        const controls = new OrbitControls(camera, canvas);
        controls.target.set(0, 0, 0); // 控制目标点
        controls.enableDamping = true; // 启用阻尼，使旋转更平滑
        controls.dampingFactor = 0.05;
        controls.minDistance = 10; // 最小距离
        controls.maxDistance = 200; // 最大距离
        controls.update();
        
        // 渲染循环函数
        let animationId = null;
        function animate() {
            animationId = requestAnimationFrame(animate);
            controls.update(); // 更新控制器
            renderer.render(scene, camera);
        }
        
        // 添加灯光
        // 环境光
        const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
        scene.add(ambientLight);
        
        // 方向光
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
        directionalLight.position.set(10, 10, 10);
        scene.add(directionalLight);
        
        // 点光源
        const pointLight = new THREE.PointLight(0xffffff, 1.0);
        pointLight.position.set(0, 20, 0);
        scene.add(pointLight);
        
        console.log('Scene initialized');
        
        // 不再创建测试模型
        
        // 加载模型
        async function loadModel() {
            try {
                const modelName = 'Terrain1Prev';
                
                // 加载 MTL 材质
                const mtlLoader = new MTLLoader();
                mtlLoader.setPath('Objects/');
                const materials = await new Promise((resolve, reject) => {
                    mtlLoader.load(
                        `${modelName}.mtl`,
                        (materials) => {
                            console.log('MTL loaded', materials);
                            materials.preload();
                            
                            // 修复黑色材质问题：遍历所有材质并设置颜色
                            materials.materials = Object.keys(materials.materials).reduce((acc, key) => {
                                const mat = materials.materials[key];
                                // 如果材质是黑色，改为白色或灰色
                                if (mat.color && mat.color.r === 0 && mat.color.g === 0 && mat.color.b === 0) {
                                    mat.color.setHex(0x888888); // 设置为灰色
                                }
                                acc[key] = mat;
                                return acc;
                            }, {});
                            
                            resolve(materials);
                        },
                        undefined,
                        reject
                    );
                });
                
                // 加载 OBJ 模型
                const objLoader = new OBJLoader();
                objLoader.setMaterials(materials);
                objLoader.setPath('Objects/');
                const model = await new Promise((resolve, reject) => {
                    objLoader.load(
                        `${modelName}.obj`,
                        (object) => {
                            console.log('OBJ loaded', object);
                            console.log('Number of children:', object.children.length);
                            
                            // 遍历所有子对象，打印信息
                            let meshCount = 0;
                            object.traverse((child) => {
                                if (child.isMesh) {
                                    meshCount++;
                                    console.log(`Mesh ${meshCount}:`, child.name, child.geometry, child.material);
                                    
                                    // 打印几何体信息
                                    if (child.geometry) {
                                        console.log(`  - Vertices: ${child.geometry.attributes.position.count}`);
                                        console.log(`  - Faces: ${child.geometry.attributes.position.count / 3}`);
                                    }
                                    
                                    // 修复材质
                                    if (child.material) {
                                        // 如果是黑色材质，替换为可见的材质
                                        if (Array.isArray(child.material)) {
                                            child.material = child.material.map(mat => {
                                                if (mat && mat.color && mat.color.r === 0 && mat.color.g === 0 && mat.color.b === 0) {
                                                    return new THREE.MeshStandardMaterial({ color: 0x888888 });
                                                }
                                                return mat;
                                            });
                                        } else {
                                            if (child.material.color && child.material.color.r === 0 && child.material.color.g === 0 && child.material.color.b === 0) {
                                                child.material = new THREE.MeshStandardMaterial({ color: 0x888888 });
                                            }
                                        }
                                    } else {
                                        // 如果没有材质，添加默认材质
                                        child.material = new THREE.MeshStandardMaterial({ color: 0x888888 });
                                    }
                                }
                            });
                            
                            console.log(`Total meshes found: ${meshCount}`);
                            
                            resolve(object);
                        },
                        undefined,
                        reject
                    );
                });
                
                // 计算模型边界框，用于居中
                const box = new THREE.Box3().setFromObject(model);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                
                console.log('Model center:', center);
                console.log('Model size:', size);
                
                // 居中模型
                model.position.x = -center.x;
                model.position.y = -center.y;
                model.position.z = -center.z;
                
                // 沿 y 轴顺时针旋转 30 度
                model.rotation.y = -Math.PI / 6;
                
                // 添加到场景
                scene.add(model);
                
                console.log('Model added to scene');
                
                // 开始渲染循环（如果还没有开始）
                if (!animationId) {
                    animate();
                }
                
            } catch (error) {
                console.error('Failed to load model:', error);
            }
        }
        
        // 开始加载模型
        loadModel();
        
        // 开始渲染循环
        if (!animationId) {
            animate();
        }
    </script>
</body>
</html>

