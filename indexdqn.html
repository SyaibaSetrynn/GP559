<!DOCTYPE html>
<html>
	<head>
		<link rel="stylesheet" href="./style.css" />
		<title>DQN Training Environment</title>
		
		<!-- TensorFlow.js -->
		<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
	</head>

	<body>
		<div id="div1"></div>
		
		<!-- Game Info Display - Fixed Overlay -->
		<div id="losUI" style="position: fixed; top: 10px; left: 10px; background: rgba(255,255,255,0.9); padding: 8px; border: 1px solid black; font-size: 12px; z-index: 1000;">
			<strong>DQN Training Environment</strong>
			<div id="agentScores">Loading scores...</div>
			<div id="testTimer">Timer: 0</div>
			<div style="font-size: 11px;">
				Camera: Mouse look, Scroll zoom<br>
				DQN: Deep Q-Network training
			</div>
		</div>

		<!-- Game Controls - Fixed Overlay -->
		<div id="game-controls" style="position: fixed; top: 10px; right: 10px; background: rgba(255,255,255,0.9); padding: 8px; border: 1px solid black; font-size: 12px; z-index: 1000; max-width: 300px;">
			<h4 style="margin: 0 0 5px 0;">Game Controls</h4>
			<div style="margin: 2px 0;">Mode: <span id="current-mode">Random</span></div>
			<div style="margin: 2px 0;">Status: <span id="system-status">Ready</span></div>
			<div style="margin: 2px 0; font-size: 10px; color: #666;">Buffer: <span id="buffer-status">0 experiences</span></div>
			

			
			<div style="margin: 3px 0;">
				<button id="reset-scene">Reset Environment</button>
				<button id="random-mode">Random Mode</button>
				<button id="debug-cp" style="font-size: 10px;">Debug CPs</button>
			</div>
			
			<div style="margin-top: 6px; border-top: 1px solid #ccc; padding-top: 4px;">
				<h5 style="margin: 0 0 3px 0;">DQN Controls</h5>
				<div style="margin: 2px 0;">
					<button id="init-dqn" style="font-size: 10px;">Initialize DQN</button>
					<button id="start-dqn" style="font-size: 10px;">Start Training</button>
				</div>
				<div style="margin: 2px 0;">
					<button id="stop-dqn" style="font-size: 10px;">Stop Training</button>
					<button id="save-dqn" style="font-size: 10px;">Save Model</button>
				</div>
				<div style="margin: 2px 0;">
					<button id="export-model" style="font-size: 10px;">Export JSON</button>
					<button id="import-model" style="font-size: 10px;">Import JSON</button>
					<input type="file" id="import-file" accept=".json" style="display: none;">
				</div>
			</div>
		</div>

		<!-- Agent State Display - Fixed Overlay -->
		<div id="red-agent-state" style="position: fixed; bottom: 10px; left: 10px; background: rgba(240,240,240,0.95); border: 1px solid #ccc; padding: 8px; font-family: 'Courier New', monospace; font-size: 10px; z-index: 1000; max-width: 350px; color: #333;">
			<div style="margin: 0 0 6px 0; font-weight: bold; font-size: 11px;">Agent 0 State Data</div>
			<div id="red-state-summary" style="margin-bottom: 6px; line-height: 1.2;">
				<div>pos: <span id="red-position">Loading...</span></div>
				<div>score: <span id="red-score">Loading...</span></div>
				<div>move: <span id="red-movement">Loading...</span></div>
				<div>target: <span id="red-nearest-cp">Loading...</span></div>
			</div>
			<div id="red-minimal-state" style="font-size: 9px; color: #666; border-top: 1px solid #ddd; padding-top: 4px;">
				<div style="margin-bottom: 2px;">state_vector:</div>
				<div id="red-state-vector" style="font-family: monospace; word-break: break-all; line-height: 1.1;">[Loading...]</div>
			</div>
		</div>


		
		<script>
			// Simple timer to show the page is working
			let timerCount = 0;
			setInterval(() => {
				timerCount++;
				const timerDiv = document.getElementById('testTimer');
				if (timerDiv) {
					timerDiv.textContent = `Timer: ${timerCount} (${new Date().toLocaleTimeString()})`;
				}
			}, 1000);
		</script>
		
	<script type="importmap">
		{
			"imports": {
				"three": "https://unpkg.com/three@0.161.0/build/three.module.js",
				"three/addons/": "https://unpkg.com/three@0.161.0/examples/jsm/"
			}
		}
	</script>

	<script type="module">
		import * as THREE from 'three';
		import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
		import { MTLLoader } from 'three/addons/loaders/MTLLoader.js';
		import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
		import { CriticalPointSystem, CP_COLORS } from './critical-point-system.js';
		import { gameStateExtractor } from './dqn/game-state-extractor.js';
		import { dqnIntegration } from './dqn/dqn-integration.js';
		
		// Expose Three.js and related systems to global scope
		window.THREE = THREE;
		window.OBJLoader = OBJLoader;
		window.MTLLoader = MTLLoader;
		window.CriticalPointSystem = CriticalPointSystem;
		window.CP_COLORS = CP_COLORS;
		window.gameStateExtractor = gameStateExtractor;
		window.dqnIntegration = dqnIntegration;

		// Red Agent State Display Update
		function updateRedAgentStateDisplay() {
			try {
				// Get the red agent (first agent, which should be red)
				const redAgent = window.gameManager?.agents?.[0];
						if (!redAgent) {
				// Update UI to show no agent found
				document.getElementById('red-position').textContent = 'No red agent found';
				document.getElementById('red-score').textContent = 'N/A';
				document.getElementById('red-movement').textContent = 'N/A';
				document.getElementById('red-nearest-cp').textContent = 'N/A';
				document.getElementById('red-state-vector').textContent = '[Agent not found]';
				return;
			}

				// Get the required system references
				const agentManager = window.gameManager;
				const mapLayout = window.mapLayout; // Use mapLayout instead of levelContent3D
				const criticalPointSystem = window.globalCPSystem;

				// Get human-readable summary
				const summary = gameStateExtractor.getStateSummary(
					redAgent, agentManager, mapLayout, criticalPointSystem
				);

				// Get minimal state vector for DQN
				const stateVector = gameStateExtractor.getMinimalStateVector(
					redAgent, agentManager, mapLayout, criticalPointSystem
				);

				// Update UI elements
				document.getElementById('red-position').textContent = summary.position || '(0.0, 0.0)';
				document.getElementById('red-score').textContent = summary.score || '0/0 CPs owned';
				document.getElementById('red-movement').textContent = summary.movement || 'Unknown';
				document.getElementById('red-nearest-cp').textContent = summary.nearestCP || 'None available';
				
				// Format state vector nicely
				const formattedVector = stateVector.map(val => 
					typeof val === 'number' ? val.toFixed(2) : val
				).join(', ');
				document.getElementById('red-state-vector').textContent = `[${formattedVector}]`;
		} catch (error) {
			console.warn('Error updating red agent state display:', error);
			document.getElementById('red-position').textContent = 'Error';
			document.getElementById('red-score').textContent = 'Error';
			document.getElementById('red-movement').textContent = 'Error';
			document.getElementById('red-nearest-cp').textContent = 'Error';
			document.getElementById('red-state-vector').textContent = '[Error extracting state]';
		}
		}

		// Start the state display update loop
		let stateUpdateInterval;
		function startRedAgentStateUpdates() {
			if (stateUpdateInterval) {
				clearInterval(stateUpdateInterval);
			}
			
			// Update every 500ms
			stateUpdateInterval = setInterval(updateRedAgentStateDisplay, 500);
			console.log('Red agent state display updates started');
		}

		// Expose functions globally for debugging
		window.updateRedAgentStateDisplay = updateRedAgentStateDisplay;
		window.startRedAgentStateUpdates = startRedAgentStateUpdates;
		
		// Setup basic game controls when page loads
		window.addEventListener('load', () => {
			console.log('Setting up DQN environment controls');
			
			const setupControls = () => {
				if (!window.gameManager) {
					setTimeout(setupControls, 200);
					return;
				}
				
				console.log('Game manager ready, connecting DQN controls');
				
				// Start red agent state display updates
				startRedAgentStateUpdates();
				
				// Start periodic buffer status updates
				setInterval(() => {
					updateBufferStatus();
				}, 1000); // Update every second
				
				// Utility function for resetting critical points (used by UI)
				window.resetCriticalPointsUtil = function() {
					const cps = window.gameManager?.criticalPointSystem;
					if (!cps) return;

					console.log('Utility: Resetting critical points...');
					console.log(`Before reset: ${cps.criticalPoints ? cps.criticalPoints.length : 0} critical points exist`);

					// Reset existing critical points to neutral state
					if (cps.criticalPoints && cps.criticalPoints.length > 0) {
						console.log(`Resetting ${cps.criticalPoints.length} existing critical points to neutral state`);
						
						cps.criticalPoints.forEach(cpData => {
							if (cpData.cp && cpData.cp.material) {
								// Reset to original/neutral color
								cpData.cp.material.color.setHex(cpData.originalColor || 0xffffff);
								cpData.cp.material.opacity = 0.8;
								
								// Reset any glow children
								if (cpData.cp.children && cpData.cp.children.length > 0) {
									cpData.cp.children.forEach(child => {
										if (child.material) {
											child.material.color.setHex(cpData.originalColor || 0xffffff);
										}
									});
								}
							}
							
							// Reset ownership and state
							cpData.ownedBy = null;
							cpData.currentOwner = null;
							if (cpData.fillProgress !== undefined) {
								cpData.fillProgress = 0;
							}
							if (cpData.currentColor) {
								cpData.currentColor = cpData.originalColor || 0xffffff;
							}
						});
						
						// Reset registry ownership but keep the critical points
						if (cps.cpsByOwner) {
							cps.cpsByOwner.clear();
						}
						
						// Reset registry states but don't clear the points themselves
						if (cps.cpRegistry) {
							cps.cpRegistry.forEach((cpData, id) => {
								cpData.ownedBy = null;
								cpData.isActivelyClaimed = false;
								cpData.claimedBy = null;
								cpData.lastClaimedTime = 0;
								if (cpData.claimHistory) {
									cpData.claimHistory = [];
								}
							});
						}
					} else {
						console.log('No existing critical points found to reset');
					}

					console.log('Utility: Critical points reset completed');
					console.log(`After reset: ${cps.criticalPoints ? cps.criticalPoints.length : 0} critical points exist`);
				};
				
				// UI elements for basic controls
				const modeSpan = document.getElementById('current-mode');
				const statusSpan = document.getElementById('system-status');
				
				console.log('Basic game controls ready');
				
				// Reset Scene
				document.getElementById('reset-scene').onclick = () => {
					console.log('Resetting environment...');
					
					// Reset agents to starting corner positions
					if (window.gameManager && window.gameManager.agents) {
						// Define starting corner positions (matching AgentTestMain.js)
						const startingPositions = [
							{ x: -4, y: 1, z: -4 }, // Red agent - back left corner
							{ x: 4, y: 1, z: 4 },   // Green agent - front right corner (opposite)
							{ x: -4, y: 1, z: 4 },  // Blue agent - front left corner
							{ x: 4, y: 1, z: -4 }   // Extra corner if needed - back right corner
						];
						
						window.gameManager.agents.forEach((agent, index) => {
							// Get starting position for this agent (cycle through corners if more agents)
							const startPos = startingPositions[index % startingPositions.length];
							
							// Reset agent mesh position
							if (agent.mesh) {
								agent.mesh.position.set(startPos.x, startPos.y, startPos.z);
								agent.mesh.rotation.set(0, 0, 0);
							}
							
							// Reset agent camera position (important for agent physics)
							if (agent.camera) {
								agent.camera.position.set(startPos.x, startPos.y, startPos.z);
							}
							
							// Reset collider position
							if (agent.collider) {
								agent.collider.start.set(startPos.x, startPos.y - 0.25, startPos.z);
								agent.collider.end.set(startPos.x, startPos.y + 0.25, startPos.z);
							}
							
							// Reset scores and state
							if (agent.claimedCriticalPoints) {
								agent.claimedCriticalPoints.clear();
							}
							if (agent.testScore !== undefined) {
								agent.testScore = 0;
							}
							if (agent.velocity) {
								agent.velocity.set(0, 0, 0);
							}
							
							// Reset movement state
							if (agent.movement) {
								agent.movement = {w: false, a: false, s: false, d: false, space: false, spaceHold: false};
							}
							
							// Reset physics
							agent.speedY = 0;
							agent.onGround = true;
							
							console.log(`Agent ${agent.agentId} reset to corner (${startPos.x}, ${startPos.y}, ${startPos.z})`);
						});
					}
					
					// Reset critical points
					if (window.resetCriticalPointsUtil) {
						window.resetCriticalPointsUtil();
					}
					
					// Update UI
					if (modeSpan) modeSpan.textContent = 'Random';
					if (statusSpan) statusSpan.textContent = 'Environment reset';
					
					console.log('Environment reset complete');
				};
				
				// Random Mode
				document.getElementById('random-mode').onclick = () => {
					console.log('Setting random mode');
					window.gameManager.setAllAgentsMode('random');
					if (modeSpan) modeSpan.textContent = 'Random';
					if (statusSpan) statusSpan.textContent = 'Random mode active';
				};
				
				// Debug Critical Points
				document.getElementById('debug-cp').onclick = () => {
					console.log('üîç DEBUGGING CRITICAL POINTS:');
					const cps = window.globalCPSystem;
					if (cps && cps.criticalPoints) {
						console.log(`Found ${cps.criticalPoints.length} critical points:`);
						cps.criticalPoints.forEach((cpData, i) => {
							const pos = cpData.cp.position;
							const inPlayArea = Math.abs(pos.x) <= 4.5 && Math.abs(pos.z) <= 4.5;
							console.log(`CP ${i}: (${pos.x.toFixed(2)}, ${pos.y.toFixed(2)}, ${pos.z.toFixed(2)}) - ${inPlayArea ? '‚úÖ IN play area' : '‚ùå OUTSIDE play area'}`);
						});
					} else {
						console.log('No critical points found');
					}
				};
				
				// Utility function to update buffer status
				function updateBufferStatus() {
					const bufferSpan = document.getElementById('buffer-status');
					if (bufferSpan && dqnIntegration) {
						try {
							const info = dqnIntegration.getPretrainingInfo();
							const bufferSize = info.currentBufferSize;
							const readyForTraining = info.readyForTraining;
							const percentage = Math.min(100, Math.round((bufferSize / info.trainingStartSize) * 100));
							
							bufferSpan.textContent = `${bufferSize} experiences (${percentage}%)`;
							bufferSpan.style.color = readyForTraining ? '#4CAF50' : '#666';
						} catch (error) {
							bufferSpan.textContent = '0 experiences';
						}
					}
				}



				// DQN Controls
				document.getElementById('init-dqn').onclick = async () => {
					console.log('Initializing DQN...');
					if (statusSpan) statusSpan.textContent = 'Initializing DQN...';
					
					try {
						await dqnIntegration.initialize(window.gameManager, {
							scene: window.scene,
							collisionWorld: window.collisionWorld,
							criticalPointSystem: window.globalCPSystem,
							mapLayout: window.mapLayout
						});
						
						if (statusSpan) statusSpan.textContent = 'DQN Ready';
						updateBufferStatus();
						console.log('DQN initialized successfully');
					} catch (error) {
						if (statusSpan) statusSpan.textContent = 'DQN Init Error';
						console.error('DQN initialization error:', error);
					}
				};
				
				document.getElementById('start-dqn').onclick = async () => {
					console.log('Starting DQN training...');
					if (statusSpan) statusSpan.textContent = 'Starting DQN training...';
					
					try {
						await dqnIntegration.startTraining(0); // Train red agent
						if (modeSpan) modeSpan.textContent = 'DQN Training';
						if (statusSpan) statusSpan.textContent = 'DQN training active';
					} catch (error) {
						if (statusSpan) statusSpan.textContent = 'DQN Start Error';
						console.error('DQN training start error:', error);
					}
				};
				
				document.getElementById('stop-dqn').onclick = () => {
					console.log('Stopping DQN training...');
					dqnIntegration.stopTraining();
					if (statusSpan) statusSpan.textContent = 'DQN training stopped';
				};
				
				document.getElementById('save-dqn').onclick = async () => {
					console.log('Saving DQN model...');
					if (statusSpan) statusSpan.textContent = 'Saving model...';
					
					try {
						const modelName = 'dqn_model_' + new Date().toISOString().slice(0, 16).replace(/[:-]/g, '');
						const success = await dqnIntegration.saveModel(modelName);
						if (statusSpan) {
							statusSpan.textContent = success ? 'Model saved' : 'Save failed';
						}
					} catch (error) {
						if (statusSpan) statusSpan.textContent = 'Save error';
						console.error('Model save error:', error);
					}
				};
				
				// Export model as JSON
				document.getElementById('export-model').onclick = async () => {
					try {
						// Get list of available models first
						const savedModels = await dqnIntegration.listSavedModels();
						
						if (savedModels.length === 0) {
							alert('No saved models to export');
							return;
						}
						
						let modelOptions = 'Select model to export:\n';
						savedModels.forEach((model, index) => {
							modelOptions += `${index + 1}. ${model.name} (${model.dateSaved})\n`;
						});
						
						const modelName = prompt(modelOptions + '\nEnter model name to export:', 
							savedModels.length > 0 ? savedModels[0].name : '');
						if (!modelName) return;
						
						if (statusSpan) statusSpan.textContent = 'Exporting...';
						const success = await dqnIntegration.exportModelAsJSON(modelName);
						
						if (success) {
							alert(`Model ${modelName} exported successfully as JSON file!`);
						} else {
							alert('Export failed. Check console for details.');
						}
						
					} catch (error) {
						if (statusSpan) statusSpan.textContent = 'Export error';
						console.error('Model export error:', error);
						alert('Export failed. Check console for details.');
					}
				};
				
				// Import model from JSON
				document.getElementById('import-model').onclick = () => {
					document.getElementById('import-file').click();
				};
				
				document.getElementById('import-file').onchange = async (event) => {
					const file = event.target.files[0];
					if (!file) return;
					
					try {
						if (statusSpan) statusSpan.textContent = 'Importing...';
						
						const importedName = await dqnIntegration.importModelFromJSON(file);
						alert(`Model imported successfully as: ${importedName}`);
						
						if (statusSpan) statusSpan.textContent = 'Import complete';
						
						// Clear the file input
						event.target.value = '';
						
					} catch (error) {
						if (statusSpan) statusSpan.textContent = 'Import error';
						console.error('Model import error:', error);
						alert('Import failed. Check console for details.');
						event.target.value = '';
					}
				};
				console.log('DQN game controls connected successfully');
				
				// Movement Tuning Control Functions
				function setupMovementTuningControls() {
					console.log('Setting up movement tuning controls...');
					
					// Update display values when sliders change
					const updateSliderDisplay = (sliderId, displayId, suffix = '') => {
						const slider = document.getElementById(sliderId);
						const display = document.getElementById(displayId);
						if (slider && display) {
							slider.addEventListener('input', (e) => {
								display.textContent = parseFloat(e.target.value).toFixed(2) + suffix;
							});
						}
					};
					
					// Setup all slider displays
					updateSliderDisplay('movement-speed', 'speed-value');
					updateSliderDisplay('direction-freq', 'freq-value');
					updateSliderDisplay('cp-seeking', 'cp-seeking-value', '%');
					updateSliderDisplay('exploration-bonus', 'exploration-value');
					updateSliderDisplay('diagonal-movement', 'diagonal-value', '%');
					
					// Apply Movement Settings Button
					document.getElementById('apply-movement-settings').onclick = () => {
						console.log('Applying movement settings...');
						
						const settings = {
							movementSpeed: parseFloat(document.getElementById('movement-speed').value),
							directionChangeFreq: parseInt(document.getElementById('direction-freq').value),
							cpSeekingChance: parseInt(document.getElementById('cp-seeking').value) / 100,
							explorationBonus: parseFloat(document.getElementById('exploration-bonus').value),
							diagonalChance: parseInt(document.getElementById('diagonal-movement').value) / 100
						};
						
						console.log('New movement settings:', settings);
						
						// Apply settings to all agents
						if (window.gameManager && window.gameManager.agents) {
							window.gameManager.agents.forEach((agent, index) => {
								// Update agent movement speed
								if (agent.movementSpeed !== undefined) {
									agent.movementSpeed = settings.movementSpeed;
								}
								
								// Update movement parameters (these will be read by the agent's movement logic)
								agent.movementTuning = {
									directionChangeFreq: settings.directionChangeFreq,
									cpSeekingChance: settings.cpSeekingChance,
									explorationBonus: settings.explorationBonus,
									diagonalChance: settings.diagonalChance
								};
								
								console.log(`Applied settings to Agent ${agent.agentId || index}`);
							});
						}
						
						// Store settings globally for new agents
						window.globalMovementSettings = settings;
						
						if (statusSpan) statusSpan.textContent = 'Movement settings applied';
						setTimeout(() => {
							if (statusSpan) statusSpan.textContent = 'Ready';
						}, 2000);
					};
					
					// Reset Movement Settings Button
					document.getElementById('reset-movement-settings').onclick = () => {
						console.log('Resetting movement settings to defaults...');
						
						// Reset sliders to default values
						document.getElementById('movement-speed').value = 0.05;
						document.getElementById('direction-freq').value = 60;
						document.getElementById('cp-seeking').value = 20;
						document.getElementById('exploration-bonus').value = 0.1;
						document.getElementById('diagonal-movement').value = 20;
						
						// Update displays
						document.getElementById('speed-value').textContent = '0.05';
						document.getElementById('freq-value').textContent = '60';
						document.getElementById('cp-seeking-value').textContent = '20%';
						document.getElementById('exploration-value').textContent = '0.10';
						document.getElementById('diagonal-value').textContent = '20%';
						
						// Apply default settings
						document.getElementById('apply-movement-settings').click();
						
						console.log('Movement settings reset to defaults');
					};
					
					// Toggle Movement Panel Button
					document.getElementById('toggle-movement-panel').onclick = () => {
						const panel = document.getElementById('movement-tuning');
						const button = document.getElementById('toggle-movement-panel');
						
						if (panel.style.display === 'none') {
							panel.style.display = 'block';
							button.textContent = 'Hide Panel';
						} else {
							panel.style.display = 'none';
							button.textContent = 'Show Movement Tuning';
							
							// Create a small show button if panel is hidden
							if (!document.getElementById('show-movement-btn')) {
								const showBtn = document.createElement('button');
								showBtn.id = 'show-movement-btn';
								showBtn.textContent = 'Movement';
								showBtn.style.cssText = 'position: fixed; top: 50%; right: 5px; transform: translateY(-50%); z-index: 1001; font-size: 8px; padding: 2px 4px; background: #ccc; color: black; border: 1px solid #999;';
								showBtn.onclick = () => {
									panel.style.display = 'block';
									button.textContent = 'Hide';
									document.body.removeChild(showBtn);
								};
								document.body.appendChild(showBtn);
							}
						}
					};
					
					console.log('Movement tuning controls ready');
				}
			};
			
			setupControls();
		});
		
		// Console helpers for testing pretraining
		window.pretrainHelpers = {
			async runPretraining() {
				console.log('üöÄ Starting pretraining from console...');
				
				// Start progress monitoring
				const progressMonitor = setInterval(() => {
					const progress = dqnIntegration.getPretrainingProgress();
					if (progress && progress.isPretraining) {
						console.log(`üìä Progress: Episode ${progress.currentEpisode}/${progress.totalEpisodes}, Step ${progress.currentStep}/${progress.stepsPerEpisode}`);
					}
				}, 2000); // Log progress every 2 seconds
				
				try {
					await dqnIntegration.runSimplePretraining(0);
					console.log('‚úÖ Pretraining completed!');
					updateBufferStatus();
				} catch (error) {
					console.error('‚ùå Pretraining error:', error);
				} finally {
					clearInterval(progressMonitor);
				}
			},
			
			getPretrainingInfo() {
				try {
					const info = dqnIntegration.getPretrainingInfo();
					console.log('üìä Pretraining Info:', info);
					return info;
				} catch (error) {
					console.error('Error getting pretraining info:', error);
					return null;
				}
			},
			
			getPretrainingProgress() {
				try {
					const progress = dqnIntegration.getPretrainingProgress();
					console.log('üìà Pretraining Progress:', progress);
					return progress;
				} catch (error) {
					console.error('Error getting pretraining progress:', error);
					return null;
				}
			},
			
			async trainWithPretraining() {
				console.log('üéØ Starting DQN training WITH pretraining...');
				try {
					await dqnIntegration.startTraining(0, true);
					console.log('‚úÖ Training with pretraining started!');
				} catch (error) {
					console.error('‚ùå Training error:', error);
				}
			}
		};
		
		console.log('DQN training system initialized');
		console.log('üí° Console helpers available: pretrainHelpers.runPretraining(), pretrainHelpers.getPretrainingInfo(), pretrainHelpers.getPretrainingProgress(), pretrainHelpers.trainWithPretraining()');
		console.log('üí° Or use the UI buttons: "Start Pretraining", "Train + Pretraining"');
		console.log('üí° Watch the UI for real-time pretraining progress display!');
	</script>


	<script src="AgentTestMain.js" type="module" defer></script>
	</body>
</html>
