<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Agent Test Environment - Load Trained Weights</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #1a1a2e;
            color: white;
            font-family: 'Courier New', monospace;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
        }
        
        .control-panel {
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #4a90e2;
            height: fit-content;
        }
        
        .control-panel h2 {
            color: #4a90e2;
            margin-top: 0;
        }
        
        button {
            background: #4a90e2;
            color: white;
            border: none;
            padding: 10px 15px;
            margin: 5px 0;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            width: 100%;
        }
        
        button:hover {
            background: #357abd;
        }
        
        button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        
        .status {
            background: rgba(74, 144, 226, 0.2);
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            font-size: 11px;
        }
        
        .weight-input {
            background: #000;
            color: #0f0;
            border: 1px solid #4a90e2;
            padding: 10px;
            border-radius: 5px;
            width: 100%;
            height: 200px;
            font-family: monospace;
            font-size: 10px;
            resize: vertical;
            box-sizing: border-box;
        }
        
        .agent-info {
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            font-size: 11px;
        }
        
        .game-area {
            background: rgba(0,0,0,0.8);
            border: 2px solid #4a90e2;
            border-radius: 10px;
            padding: 20px;
            min-height: 600px;
        }
        
        .game-canvas {
            width: 100%;
            height: 500px;
            background: #000;
            border: 1px solid #333;
            border-radius: 5px;
        }
        
        .agent-actions {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 10px;
            font-size: 11px;
        }
        
        .agent-action {
            background: rgba(74, 144, 226, 0.2);
            padding: 8px;
            border-radius: 3px;
            text-align: center;
        }
        
        .log {
            background: #000;
            color: #0f0;
            padding: 10px;
            border-radius: 5px;
            height: 150px;
            overflow-y: scroll;
            font-family: monospace;
            font-size: 10px;
            line-height: 1.3;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <!-- TensorFlow.js -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    
    <!-- DQN Training System -->
    <script src="dqn_training.js"></script>
    
    <div class="container">
        <div class="control-panel">
            <h2>Agent Test Controller</h2>
            
            <div class="status" id="system-status">Ready to load weights</div>
            
            <h3>Load Agent Weights</h3>
            <p style="font-size: 10px;">Paste the WEIGHT_X= lines from training console:</p>
            
            <label>Paste Individual Weight Layers Here:</label>
            <textarea class="weight-input" id="weights-all" placeholder='Paste the WEIGHT_0=...
WEIGHT_1=...
WEIGHT_2=...
etc. lines here' style="height: 300px;"></textarea>
            
            <button id="load-weights">Load Weights into Agents</button>
            <button id="start-test" disabled>Start Agent Test</button>
            <button id="reset-test" disabled>Reset Test</button>
            <button id="toggle-auto" disabled>Auto Mode: OFF</button>
            
            <div class="agent-info" id="agent-info">
                <strong>Agent Status:</strong><br>
                Agent 0: Not loaded<br>
                Agent 1: Not loaded<br>
                Agent 2: Not loaded
            </div>
            
            <div class="log" id="test-log">Waiting for weights to be loaded...</div>
        </div>
        
        <div class="game-area">
            <h2>Agent Behavior Visualization</h2>
            <div class="game-canvas" id="game-canvas">
                <canvas id="visualization" width="800" height="480"></canvas>
            </div>
            
            <div class="agent-actions" id="agent-actions">
                <div class="agent-action">
                    <strong>Agent 0 (Red):</strong><br>
                    <span id="action-0">Waiting...</span>
                </div>
                <div class="agent-action">
                    <strong>Agent 1 (Green):</strong><br>
                    <span id="action-1">Waiting...</span>
                </div>
                <div class="agent-action">
                    <strong>Agent 2 (Blue):</strong><br>
                    <span id="action-2">Waiting...</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        let testManager = null;
        let isTestRunning = false;
        let autoMode = false;
        let animationId = null;
        
        // Mock game environment for testing
        class TestGameEnvironment extends GameEnvironment {
            constructor() {
                super(null, 1000);
                this.agentPositions = [
                    [0, 1, 0],    // Agent 0 - Red
                    [-3, 1, 3],   // Agent 1 - Green  
                    [3, 1, -3]    // Agent 2 - Blue
                ];
                this.criticalPoints = this.generateRandomCriticalPoints();
                this.ownedPoints = { 0: 0, 1: 0, 2: 0 };
            }
            
            generateRandomCriticalPoints() {
                const points = [];
                for (let i = 0; i < 15; i++) {
                    points.push({
                        position: [
                            (Math.random() - 0.5) * 8,
                            1,
                            (Math.random() - 0.5) * 8
                        ],
                        color: Math.random() < 0.7 ? null : Math.floor(Math.random() * 3),
                        available: Math.random() < 0.9
                    });
                }
                return points;
            }
            
            getCurrentGameState() {
                return {
                    agent_position: this.agentPositions[0],
                    critical_points: this.criticalPoints,
                    agent_owned_points: this.ownedPoints,
                    time_remaining: 0.8,
                    navigation_grid: Array(15 * 15).fill(0).map(() => Math.random() < 0.05 ? 1 : 0),
                    nearest_unclaimed_distance: Math.random() * 0.5,
                    nearest_enemy_distance: Math.random() * 0.3,
                    map_size: 8
                };
            }
            
            step(action, agentId) {
                // Move agent based on action
                const moveDistance = 0.1;
                const pos = this.agentPositions[agentId];
                
                switch(action) {
                    case 0: // strafe_left
                        pos[0] -= moveDistance;
                        break;
                    case 1: // strafe_right
                        pos[0] += moveDistance;
                        break;
                    case 2: // move_forward
                        pos[2] -= moveDistance;
                        break;
                    case 3: // move_backward
                        pos[2] += moveDistance;
                        break;
                    case 4: // stay
                        break;
                }
                
                // Keep agents in bounds
                pos[0] = Math.max(-4, Math.min(4, pos[0]));
                pos[2] = Math.max(-4, Math.min(4, pos[2]));
                
                // Simple reward calculation
                let reward = 0;
                
                // Check if agent captured any critical points
                this.criticalPoints.forEach((cp, idx) => {
                    if (cp.available && cp.color === null) {
                        const dist = Math.sqrt(
                            (pos[0] - cp.position[0]) ** 2 + 
                            (pos[2] - cp.position[2]) ** 2
                        );
                        if (dist < 0.3) {
                            cp.color = agentId;
                            this.ownedPoints[agentId]++;
                            reward += 10;
                            log(`Agent ${agentId} captured critical point! Total: ${this.ownedPoints[agentId]}`);
                        }
                    }
                });
                
                // Small movement penalty
                if (action !== 4) {
                    reward -= 0.01;
                }
                
                const state = this.getCurrentGameState();
                return {
                    state: this.processor.processState(state, agentId),
                    reward: reward,
                    done: false
                };
            }
            
            reset() {
                this.agentPositions = [
                    [Math.random() * 2 - 1, 1, Math.random() * 2 - 1],
                    [Math.random() * 2 - 1, 1, Math.random() * 2 - 1],
                    [Math.random() * 2 - 1, 1, Math.random() * 2 - 1]
                ];
                this.criticalPoints = this.generateRandomCriticalPoints();
                this.ownedPoints = { 0: 0, 1: 0, 2: 0 };
                
                const state = this.getCurrentGameState();
                return this.processor.processState(state, 0);
            }
        }
        
        // Test manager for running loaded agents
        class AgentTestManager {
            constructor() {
                this.env = new TestGameEnvironment();
                this.agents = [];
                this.isRunning = false;
                
                // Action names for display
                this.actionNames = {
                    0: "Strafe Left",
                    1: "Strafe Right", 
                    2: "Move Forward",
                    3: "Move Backward",
                    4: "Stay Still"
                };
            }
            
            async loadAgentWeights(agentId, agentData) {
                try {
                    // Create a new DQN agent
                    const stateDim = this.env.processor.computeStateDim();
                    const agent = new DQNAgent({ 
                        stateDim: stateDim,
                        actionDim: 5,
                        epsilonStart: 0.0, // No exploration for testing
                        epsilonEnd: 0.0
                    });
                    
                    // Convert weight data back to tensors
                    const weightTensors = agentData.weights.map(weightData => {
                        return tf.tensor(weightData.values, weightData.shape);
                    });
                    
                    // Set the weights in the Q-network
                    agent.qNetwork.model.setWeights(weightTensors);
                    
                    // Set other agent properties
                    if (agentData.epsilon !== undefined) {
                        agent.epsilon = agentData.epsilon;
                    }
                    if (agentData.stepCount !== undefined) {
                        agent.stepCount = agentData.stepCount;
                    }
                    
                    // Store the agent
                    if (this.agents.length <= agentId) {
                        this.agents.length = agentId + 1;
                    }
                    this.agents[agentId] = agent;
                    
                    log(`Agent ${agentId} weights loaded successfully (epsilon: ${agent.epsilon.toFixed(3)})`);
                    return true;
                    
                } catch (error) {
                    console.error(`Error loading weights for agent ${agentId}:`, error);
                    log(`Failed to load Agent ${agentId}: ${error.message}`);
                    return false;
                }
            }
            
            parseWeightsFromText(weightsText) {
                const weightLayers = [];
                let epsilon = 0.0;
                let stepCount = 0;
                
                // Split text into lines and find WEIGHT_X= lines
                const lines = weightsText.split('\n');
                
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue; // Skip empty lines
                    
                    // Try to parse as WEIGHT_X= format first
                    const weightMatch = line.match(/WEIGHT_(\d+)=(.+)$/);
                    if (weightMatch) {
                        const layerIdx = parseInt(weightMatch[1]);
                        const weightJson = weightMatch[2];
                        
                        try {
                            const weightData = JSON.parse(weightJson);
                            weightLayers[layerIdx] = weightData;
                            log(`Found weight layer ${layerIdx}`);
                        } catch (error) {
                            console.error(`Error parsing weight layer ${layerIdx}:`, error);
                            log(`Invalid JSON for weight layer ${layerIdx}`);
                        }
                    }
                    // If not WEIGHT_X= format, try to parse as raw JSON (for simple input)
                    else if (line.startsWith('{') || line.startsWith('[')) {
                        try {
                            const weightData = JSON.parse(line);
                            weightLayers[i] = weightData;
                            log(`Found weight layer ${i} (raw JSON)`);
                        } catch (error) {
                            console.error(`Error parsing raw JSON at line ${i}:`, error);
                            log(`Invalid JSON at line ${i}`);
                        }
                    }
                    // If it's just a number, create a simple weight structure
                    else if (!isNaN(parseFloat(line))) {
                        const value = parseFloat(line);
                        // Create a simple weight structure for testing
                        const weightData = {
                            shape: [1],
                            values: [value]
                        };
                        weightLayers[i] = weightData;
                        log(`Found simple weight ${value} at layer ${i}`);
                    }
                    
                    // Match epsilon and step count
                    const epsilonMatch = line.match(/EPSILON=(.+)$/);
                    if (epsilonMatch) {
                        epsilon = parseFloat(epsilonMatch[1]);
                    }
                    
                    const stepMatch = line.match(/STEP_COUNT=(.+)$/);
                    if (stepMatch) {
                        stepCount = parseInt(stepMatch[1]);
                    }
                }
                
                // Return structured weights for all 3 agents (same weights for all)
                const agentWeights = {};
                for (let agentId = 0; agentId < 3; agentId++) {
                    agentWeights[agentId] = {
                        weights: weightLayers,
                        epsilon: epsilon,
                        stepCount: stepCount
                    };
                }
                
                log(`Parsed ${weightLayers.length} weight layers`);
                return agentWeights;
            }
            
            async runTestStep() {
                if (!this.isRunning || this.agents.length === 0) return;
                
                // Get current state and have each agent choose action
                const actions = [];
                const state = this.env.reset();
                
                for (let agentId = 0; agentId < 3; agentId++) {
                    if (this.agents[agentId]) {
                        try {
                            const agentState = this.env.processor.processState(
                                this.env.getCurrentGameState(), 
                                agentId
                            );
                            const action = this.agents[agentId].selectAction(agentState, false);
                            actions[agentId] = action;
                            
                            // Update UI
                            const actionElement = document.getElementById(`action-${agentId}`);
                            if (actionElement) {
                                actionElement.textContent = this.actionNames[action];
                            }
                            
                        } catch (error) {
                            console.error(`Agent ${agentId} action error:`, error);
                            actions[agentId] = 4; // Default to stay
                        }
                    } else {
                        actions[agentId] = 4; // Stay if no agent loaded
                    }
                }
                
                // Execute actions in environment
                for (let agentId = 0; agentId < 3; agentId++) {
                    this.env.step(actions[agentId], agentId);
                }
                
                // Update visualization
                this.updateVisualization();
                
                // Continue if auto mode
                if (autoMode && this.isRunning) {
                    setTimeout(() => this.runTestStep(), 200); // 5 FPS
                }
            }
            
            updateVisualization() {
                const canvas = document.getElementById('visualization');
                const ctx = canvas.getContext('2d');
                
                // Clear canvas
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw grid
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                for (let i = 0; i <= 16; i++) {
                    const x = (i / 16) * canvas.width;
                    const y = (i / 16) * canvas.height;
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvas.height);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                }
                
                // Convert world coords to screen coords
                const worldToScreen = (worldPos) => {
                    const x = ((worldPos[0] + 4) / 8) * canvas.width;
                    const y = ((worldPos[2] + 4) / 8) * canvas.height;
                    return [x, y];
                };
                
                // Draw critical points
                this.env.criticalPoints.forEach((cp, idx) => {
                    const [x, y] = worldToScreen(cp.position);
                    
                    if (cp.color === null) {
                        ctx.fillStyle = '#fff';
                    } else if (cp.color === 0) {
                        ctx.fillStyle = '#f44';
                    } else if (cp.color === 1) {
                        ctx.fillStyle = '#4f4';
                    } else {
                        ctx.fillStyle = '#44f';
                    }
                    
                    ctx.beginPath();
                    ctx.arc(x, y, 6, 0, 2 * Math.PI);
                    ctx.fill();
                });
                
                // Draw agents
                const agentColors = ['#f44', '#4f4', '#44f'];
                this.env.agentPositions.forEach((pos, agentId) => {
                    const [x, y] = worldToScreen(pos);
                    
                    ctx.fillStyle = agentColors[agentId];
                    ctx.beginPath();
                    ctx.arc(x, y, 12, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Agent label
                    ctx.fillStyle = '#fff';
                    ctx.font = '12px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText(`${agentId}`, x, y + 4);
                });
                
                // Draw scores
                ctx.fillStyle = '#fff';
                ctx.font = '14px monospace';
                ctx.textAlign = 'left';
                ctx.fillText(`Scores - Red: ${this.env.ownedPoints[0]} Green: ${this.env.ownedPoints[1]} Blue: ${this.env.ownedPoints[2]}`, 10, 20);
            }
            
            startTest() {
                this.isRunning = true;
                this.runTestStep();
            }
            
            stopTest() {
                this.isRunning = false;
            }
            
            resetTest() {
                this.stopTest();
                this.env.reset();
                this.updateVisualization();
                
                // Clear action displays
                for (let i = 0; i < 3; i++) {
                    const actionElement = document.getElementById(`action-${i}`);
                    if (actionElement) {
                        actionElement.textContent = 'Ready';
                    }
                }
            }
        }
        
        function log(message) {
            const logDiv = document.getElementById('test-log');
            const timestamp = new Date().toLocaleTimeString();
            logDiv.innerHTML += `[${timestamp}] ${message}\n`;
            logDiv.scrollTop = logDiv.scrollHeight;
        }
        
        function updateStatus(message) {
            document.getElementById('system-status').textContent = message;
            log(message);
        }
        
        function updateAgentInfo() {
            const info = document.getElementById('agent-info');
            const statuses = [];
            
            for (let i = 0; i < 3; i++) {
                if (testManager && testManager.agents[i]) {
                    statuses.push(`Agent ${i}: Loaded âœ“`);
                } else {
                    statuses.push(`Agent ${i}: Not loaded`);
                }
            }
            
            info.innerHTML = `<strong>Agent Status:</strong><br>${statuses.join('<br>')}`;
        }
        
        async function loadWeights() {
            updateStatus('Loading agent weights...');
            
            try {
                testManager = new AgentTestManager();
                let loadedCount = 0;
                
                // Get the pasted weights text
                const weightsInput = document.getElementById('weights-all');
                const weightsText = weightsInput.value.trim();
                
                if (!weightsText) {
                    updateStatus('Please paste the WEIGHT_X= lines from training console');
                    return;
                }
                
                // Parse the weights from the text
                const agentWeights = testManager.parseWeightsFromText(weightsText);
                
                // Load each agent's weights
                for (let agentId = 0; agentId < 3; agentId++) {
                    if (agentWeights[agentId]) {
                        const success = await testManager.loadAgentWeights(agentId, agentWeights[agentId]);
                        if (success) loadedCount++;
                    } else {
                        log(`No weights found for Agent ${agentId}`);
                    }
                }
                
                if (loadedCount > 0) {
                    updateStatus(`Successfully loaded ${loadedCount}/3 agents`);
                    document.getElementById('start-test').disabled = false;
                    document.getElementById('reset-test').disabled = false;
                    document.getElementById('toggle-auto').disabled = false;
                    
                    // Initialize visualization
                    testManager.updateVisualization();
                } else {
                    updateStatus('No valid weights were loaded - check format');
                }
                
                updateAgentInfo();
                
            } catch (error) {
                console.error('Load weights error:', error);
                updateStatus(`Failed to load weights: ${error.message}`);
            }
        }
        
        function startTest() {
            if (testManager) {
                testManager.startTest();
                updateStatus('Agent test running...');
                document.getElementById('start-test').disabled = true;
            }
        }
        
        function resetTest() {
            if (testManager) {
                testManager.resetTest();
                updateStatus('Test environment reset');
                document.getElementById('start-test').disabled = false;
            }
        }
        
        function toggleAuto() {
            autoMode = !autoMode;
            const button = document.getElementById('toggle-auto');
            button.textContent = `Auto Mode: ${autoMode ? 'ON' : 'OFF'}`;
            
            if (autoMode && testManager && !testManager.isRunning) {
                startTest();
            }
        }
        
        // Event listeners
        document.getElementById('load-weights').addEventListener('click', loadWeights);
        document.getElementById('start-test').addEventListener('click', startTest);
        document.getElementById('reset-test').addEventListener('click', resetTest);
        document.getElementById('toggle-auto').addEventListener('click', toggleAuto);
        
        // Initialize when TensorFlow is ready
        tf.ready().then(() => {
            updateStatus('System ready - Load trained weights to begin');
            log('TensorFlow.js initialized');
            log('Paste the weights from training console into the text areas above');
        });
    </script>
</body>
</html>
