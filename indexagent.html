<!DOCTYPE html>
<html>
	<head>
		<link rel="stylesheet" href="./style.css" />
		<title>Agent Test Environment</title>
		<!-- Load TensorFlow.js -->
		<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
	</head>

	<body>
		<div id="div1"></div>
		

		
		<!-- Game Info Display - Fixed Overlay -->
		<div id="losUI" style="position: fixed; top: 10px; left: 10px; background: rgba(255,255,255,0.9); padding: 8px; border: 1px solid black; font-size: 12px; z-index: 1000;">
			<strong>Agent Test Environment</strong>
			<div id="agentScores">Loading scores...</div>
			<div id="testTimer">Timer: 0</div>
			<div style="font-size: 11px;">
				Camera: Mouse look, Scroll zoom
			</div>
		</div>

		<!-- DQN Controls - Fixed Overlay -->
		<div id="dqn-controls" style="position: fixed; top: 10px; right: 10px; background: rgba(255,255,255,0.9); padding: 8px; border: 1px solid black; font-size: 12px; z-index: 1000; max-width: 350px;">
			<h4 style="margin: 0 0 5px 0;">DQN Training System</h4>
			<div style="margin: 2px 0;">Mode: <span id="current-mode">Random</span> | Phase: <span id="current-phase">Idle</span></div>
			<div style="margin: 2px 0;">Status: <span id="system-status">Ready</span></div>
			
			<div style="margin: 3px 0;">
				<button id="reset-scene">Reset</button>
				<button id="random-mode">Random Mode</button>
			</div>
			
			<div style="margin: 2px 0; font-size: 11px; color: #666;">
				<em>Episode-based training handles data collection automatically</em>
			</div>
			
			<div style="margin: 3px 0;">
				<button id="test-episode">Test Episode (Step 1)</button>
				<button id="test-training">Test Training (Step 2)</button>
				<button id="train-network">Full Training</button>
				<button id="export-weights">Export Weights</button>
			</div>
			<div style="margin: 2px 0; font-size: 11px;">
				Loss: <span id="training-loss">N/A</span> | Status: <span id="network-status">Not Trained</span>
			</div>
			
			<div style="margin: 3px 0;">
				<button id="dqn-mode">Enable DQN</button>
				<button id="load-weights">Load Weights</button>
			</div>
			<div style="margin: 2px 0; font-size: 11px;">
				Explore: <input type="range" id="epsilon-slider" min="0" max="100" value="5" style="width: 60px;"> <span id="epsilon-value">5%</span>
			</div>
			<div style="margin: 2px 0; font-size: 11px;">
				Smart Decisions: <span id="smart-decisions">0</span>
			</div>
			
			<div style="margin: 3px 0; font-size: 11px;">
				<strong>Progress:</strong> <span id="progress-text">Ready</span>
			</div>
		</div>
		
		<script>
			// Simple timer to show the page is working
			let timerCount = 0;
			setInterval(() => {
				timerCount++;
				const timerDiv = document.getElementById('testTimer');
				if (timerDiv) {
					timerDiv.textContent = `Timer: ${timerCount} (${new Date().toLocaleTimeString()})`;
				}
			}, 1000);
		</script>
		

		
	<script type="importmap">
		{
			"imports": {
				"three": "https://unpkg.com/three@0.161.0/build/three.module.js",
				"three/addons/": "https://unpkg.com/three@0.161.0/examples/jsm/"
			}
		}
	</script>

	<script type="module">
		import * as THREE from 'three';
		import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
		import { MTLLoader } from 'three/addons/loaders/MTLLoader.js';
		import { DQNDataCollector } from './dqn_system.js';
		import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
		import { CriticalPointSystem, CP_COLORS } from './critical-point-system.js';
		
		// Expose Three.js and related systems to global scope
		window.THREE = THREE;
		window.OBJLoader = OBJLoader;
		window.MTLLoader = MTLLoader;
		window.CriticalPointSystem = CriticalPointSystem;
		window.CP_COLORS = CP_COLORS;
		
		// Initialize DQN System
		const dqnDataCollector = new DQNDataCollector();
		window.dqnDataCollector = dqnDataCollector;
		
		// Wait for TensorFlow.js to be ready
		let tfReady = false;
		const waitForTensorFlow = async () => {
			if (typeof tf !== 'undefined') {
				try {
					await tf.ready();
					tfReady = true;
					console.log('TensorFlow.js is ready for training');
				} catch (error) {
					console.error('TensorFlow.js initialization error:', error);
				}
			} else {
				// Wait a bit more for TensorFlow to load
				setTimeout(waitForTensorFlow, 100);
			}
		};
		
		// Start waiting for TensorFlow
		waitForTensorFlow();
		
		// Setup DQN UI when page loads
		window.addEventListener('load', () => {
			console.log('Setting up DQN controls');
			
			const setupControls = () => {
				if (!window.gameManager) {
					setTimeout(setupControls, 200);
					return;
				}
				
				console.log('Game manager ready, connecting DQN controls');
				
				// UI elements
				const modeSpan = document.getElementById('current-mode');
				const statusSpan = document.getElementById('system-status');
				const expCountSpan = document.getElementById('experience-count');
				const rateSpan = document.getElementById('collection-rate');
				
				// Episode-based training handles data collection automatically
				console.log('ðŸŽ“ Episode-based training system ready');
				
				// Reset Scene
				document.getElementById('reset-scene').onclick = () => {
					window.location.reload();
				};
				
				// Random Mode
				document.getElementById('random-mode').onclick = () => {
					console.log('Setting random mode');
					window.gameManager.setAllAgentsMode('random');
					if (modeSpan) modeSpan.textContent = 'Random';
					if (statusSpan) statusSpan.textContent = 'Random mode';
				};
				
				// Test Training - Step 2: Episode-Based Learning Loop
				document.getElementById('test-training').onclick = async () => {
					console.log('ðŸ§ª === TESTING STEP 2: EPISODE-BASED LEARNING ===');
					console.log('Testing short training session with immediate learning');
					
					// Check TensorFlow.js
					if (typeof tf === 'undefined') {
						alert('TensorFlow.js is still loading. Please wait a moment and try again.');
						return;
					}
					
					try {
						// Import new trainer
						const { EpisodeBasedTrainer } = await import('./dqn_system.js');
						const trainer = new EpisodeBasedTrainer();
						
						// Initialize trainer
						console.log('ðŸ—ï¸  Initializing Episode-Based Trainer...');
						const initialized = await trainer.initialize(window.gameManager, dqnDataCollector);
						
						if (!initialized) {
							throw new Error('Failed to initialize episode-based trainer');
						}
						
						// Update UI
						if (modeSpan) modeSpan.textContent = 'Testing Learning';
						if (statusSpan) statusSpan.textContent = 'Running test training...';
						document.getElementById('progress-text').textContent = 'Step 2: Testing episode-based learning';
						
						// Run short training session (3 episodes, 5 seconds each)
						console.log('ðŸŽ¬ Running test training: 3 episodes Ã— 5 seconds');
						const success = await trainer.runEpisodeBasedTraining({
							episodes: 3,
							episodeLength: 5000, // 5 second episodes
							onEpisodeComplete: async (episode, totalEpisodes, stats) => {
								console.log(`ðŸ“Š Episode ${episode}/${totalEpisodes} Results:`);
								console.log(`   Experiences: ${stats.experienceCount}, Reward: ${stats.totalReward.toFixed(2)}`);
								console.log(`   CPs Captured: ${stats.cpsCaptured}, Loss: ${stats.loss ? stats.loss.toFixed(4) : 'N/A'}`);
								
								// Update UI
								document.getElementById('progress-text').textContent = `Episode ${episode}/3 complete`;
								if (stats.loss) {
									document.getElementById('training-loss').textContent = stats.loss.toFixed(4);
								}
							},
							onTrainingComplete: async (learningStats) => {
								console.log('ðŸ“ˆ === STEP 2 TEST COMPLETE ===');
								console.log('Learning Statistics:');
								console.log(`   Episodes completed: ${learningStats.episodeRewards.length}`);
								console.log(`   Average reward: ${learningStats.averageReward.toFixed(3)}`);
								console.log(`   Average loss: ${learningStats.averageLoss.toFixed(4)}`);
								console.log(`   Best episode: ${learningStats.bestEpisodeReward.toFixed(2)}`);
								console.log(`   Training time: ${(learningStats.totalTrainingTime/1000).toFixed(1)}s`);
							}
						});
						
						if (success) {
							console.log('âœ… Step 2 testing complete! Episode-based learning is working.');
							console.log('ðŸŽ“ The network learned from each episode immediately');
							console.log('ðŸš€ Ready for full training sessions!');
							
							// Update UI
							if (modeSpan) modeSpan.textContent = 'Learning Test Complete';
							if (statusSpan) statusSpan.textContent = 'Network learned from episodes';
							document.getElementById('progress-text').textContent = 'Step 2 âœ…: Episode learning working!';
							document.getElementById('network-status').textContent = 'Test Trained';
							
							// Store test network
							window.testTrainer = trainer;
							window.trainedNetwork = trainer.network;
							
						} else {
							throw new Error('Episode-based learning test failed');
						}
						
					} catch (error) {
						console.error('âŒ Step 2 testing failed:', error);
						if (modeSpan) modeSpan.textContent = 'Learning Test Failed';
						if (statusSpan) statusSpan.textContent = 'Error: ' + error.message;
						alert('Step 2 test failed: ' + error.message);
					}
				};
				
				// Full Training - Complete Episode-Based Training Session
				document.getElementById('train-network').onclick = async () => {
					console.log('ðŸŽ“ === FULL EPISODE-BASED TRAINING SESSION ===');
					console.log('ðŸŽ¯ OpenAI Multi-Agent Style - Learn from actual gameplay');
					
					// Check TensorFlow.js
					if (typeof tf === 'undefined') {
						alert('TensorFlow.js is still loading. Please wait a moment and try again.');
						return;
					}
					
					// Training parameters (optimized for good learning)
					const episodeLength = 15000;  // 15 seconds per episode
					const totalEpisodes = 25;     // 25 episodes = ~6.5 minutes
					const estimatedTime = (episodeLength * totalEpisodes) / 1000 / 60;
					
					console.log(`ðŸ“Š Training Plan: ${totalEpisodes} episodes Ã— ${episodeLength/1000}s = ~${estimatedTime.toFixed(1)} minutes`);
					console.log('ðŸ”„ Each episode: Reset â†’ Play â†’ Learn â†’ Repeat');
					
					// Confirm with user
					const confirmed = confirm(`Start full training session (~${estimatedTime.toFixed(1)} minutes)?`);
					if (!confirmed) {
						console.log('Training cancelled by user');
						return;
					}
					
					try {
						// Import and initialize trainer
						const { EpisodeBasedTrainer } = await import('./dqn_system.js');
						const trainer = new EpisodeBasedTrainer();
						
						console.log('ðŸ—ï¸  Initializing full training session...');
						await trainer.initialize(window.gameManager, dqnDataCollector);
						
						// Update UI
						if (modeSpan) modeSpan.textContent = 'Full Training';
						if (statusSpan) statusSpan.textContent = 'Running full session...';
						document.getElementById('progress-text').textContent = 'Full training in progress...';
						
						// Store trainer globally for potential stopping
						window.currentTrainer = trainer;
						
						// Run full training session
						const success = await trainer.runEpisodeBasedTraining({
							episodes: totalEpisodes,
							episodeLength: episodeLength,
							onEpisodeComplete: async (episode, totalEpisodes, stats) => {
								const lossSpan = document.getElementById('training-loss');
								const networkSpan = document.getElementById('network-status');
								const progressSpan = document.getElementById('progress-text');
								
								// Update UI with detailed progress
								if (lossSpan && stats.loss) lossSpan.textContent = stats.loss.toFixed(4);
								if (networkSpan) networkSpan.textContent = `Episode ${episode}/${totalEpisodes}`;
								if (progressSpan) progressSpan.textContent = `${episode}/${totalEpisodes} - ${stats.cpsCaptured} CPs, ${stats.experienceCount} exp`;
								
								// Detailed logging every 5 episodes
								if (episode % 5 === 0 || episode === totalEpisodes) {
									console.log(`ðŸŽ¬ Episode ${episode}/${totalEpisodes} Summary:`);
									console.log(`   Reward: ${stats.totalReward.toFixed(2)}, Loss: ${stats.loss ? stats.loss.toFixed(4) : 'N/A'}`);
									console.log(`   CPs: ${stats.cpsCaptured}, Exp: ${stats.experienceCount}, Duration: ${(stats.actualDuration/1000).toFixed(1)}s`);
								}
							},
							onTrainingComplete: async (learningStats) => {
								console.log('ðŸ === FULL TRAINING SESSION COMPLETED ===');
								console.log(`ðŸ“Š Final Statistics:`);
								console.log(`   Total episodes: ${learningStats.episodeRewards.length}`);
								console.log(`   Training time: ${(learningStats.totalTrainingTime/1000/60).toFixed(1)} minutes`);
								console.log(`   Best episode reward: ${learningStats.bestEpisodeReward.toFixed(2)}`);
								console.log(`   Final average loss: ${learningStats.averageLoss.toFixed(4)}`);
								console.log(`   Average reward: ${learningStats.averageReward.toFixed(3)}`);
								console.log('ðŸ§  Network learned from real multi-agent gameplay!');
							}
						});
						
						// Clean up trainer reference
						window.currentTrainer = null;
						
						if (success) {
							console.log('âœ… Full episode-based training completed successfully!');
							console.log('ðŸŽ¯ Network ready for smart agent mode');
							console.log('ðŸ’¾ Export weights to save this trained model');
							
							// Update UI
							if (modeSpan) modeSpan.textContent = 'Training Complete';
							if (statusSpan) statusSpan.textContent = 'Fully trained network';
							document.getElementById('network-status').textContent = 'Episode-Trained';
							document.getElementById('progress-text').textContent = 'Training complete! Ready for smart mode';
							
							// Store trained network
							window.trainedNetwork = trainer.network;
							
							// Return to random mode
							window.gameManager.setAllAgentsMode('random');
							
						} else {
							throw new Error('Full training session failed');
						}
						
					} catch (error) {
						console.error('âŒ Full training failed:', error);
						if (modeSpan) modeSpan.textContent = 'Training Failed';
						if (statusSpan) statusSpan.textContent = 'Error: ' + error.message;
						alert('Full training failed: ' + error.message);
						window.gameManager.setAllAgentsMode('random');
					}
				};
			
			// Export Weights - Save trained network to file
			document.getElementById('export-weights').onclick = async () => {
				if (!window.trainedNetwork) {
					alert('No trained network available. Train the network first.');
					console.log('âŒ No trained network to export');
					return;
				}
				
				try {
					console.log('=== EXPORTING TRAINED WEIGHTS ===');
					
					// Get weights from the trained network
					const weights = await window.trainedNetwork.getWeights();
					const exportData = {
						weights: weights,
						stateSize: 14,
						actionSize: 4,
						timestamp: new Date().toISOString(),
						version: '1.0'
					};
					
					// Create downloadable file
					const dataStr = JSON.stringify(exportData, null, 2);
					const dataBlob = new Blob([dataStr], {type: 'application/json'});
					const url = URL.createObjectURL(dataBlob);
					
					// Create download link
					const downloadLink = document.createElement('a');
					downloadLink.href = url;
					downloadLink.download = `dqn-weights-${Date.now()}.json`;
					downloadLink.style.display = 'none';
					
					// Trigger download
					document.body.appendChild(downloadLink);
					downloadLink.click();
					document.body.removeChild(downloadLink);
					URL.revokeObjectURL(url);
					
					console.log('âœ… Weights exported successfully to file');
					console.log(`File name: dqn-weights-${Date.now()}.json`);
					
					if (statusSpan) statusSpan.textContent = 'Weights exported';
					
				} catch (error) {
					console.error('âŒ Failed to export weights:', error);
					alert('Failed to export weights: ' + error.message);
				}
			};
			
			// Load Weights - Load trained network from file
			document.getElementById('load-weights').onclick = () => {
				console.log('=== LOADING WEIGHTS FROM FILE ===');
				
				// Create file input element
				const fileInput = document.createElement('input');
				fileInput.type = 'file';
				fileInput.accept = '.json';
				fileInput.style.display = 'none';
				
				fileInput.onchange = async (event) => {
					const file = event.target.files[0];
					if (!file) return;
					
					try {
						console.log(`Reading file: ${file.name}`);
						
						// Read file content
						const text = await file.text();
						const weightData = JSON.parse(text);
						
						console.log('Parsed weight data:', weightData);
						console.log('Weight data keys:', Object.keys(weightData));
						
						// Validate weight data
						if (!weightData.weights || !weightData.stateSize || !weightData.actionSize) {
							throw new Error('Invalid weight file format. Expected: weights, stateSize, actionSize');
						}
						
						if (weightData.stateSize !== 14 || weightData.actionSize !== 4) {
							throw new Error(`Incompatible network size. Expected 14 inputs, 4 outputs. Got ${weightData.stateSize} inputs, ${weightData.actionSize} outputs.`);
						}
						
						console.log('Weight validation passed');
						console.log(`Weights array length: ${weightData.weights.length}`);
						
						// Import weights into DQN system
						const { SimpleDQNNetwork } = await import('./dqn_system.js');
						const network = new SimpleDQNNetwork();
						network.createModel();
						
						console.log('Created new network, attempting to load weights...');
						
						const loadResult = network.setWeights(weightData.weights);
						console.log('Weight loading result:', loadResult);
						
						if (loadResult) {
							window.trainedNetwork = network;
							
							console.log('âœ… Weights loaded successfully from file');
							console.log(`File: ${file.name}`);
							console.log(`Timestamp: ${weightData.timestamp || 'Unknown'}`);
							console.log('Network is ready for smart agent mode');
							
							// Update UI
							if (modeSpan) modeSpan.textContent = 'Weights Loaded';
							if (statusSpan) statusSpan.textContent = 'Loaded from file';
							document.getElementById('network-status').textContent = 'Loaded & Ready';
							
						} else {
							throw new Error('Failed to load weights into neural network');
						}
						
					} catch (error) {
						console.error('âŒ Failed to load weights:', error);
						console.error('Error details:', error.stack);
						alert('Failed to load weights: ' + error.message);
					}
					
					// Clean up
					document.body.removeChild(fileInput);
				};
				
				// Trigger file selection
				document.body.appendChild(fileInput);
				fileInput.click();
			};
			
			// Enable DQN Mode
			document.getElementById('dqn-mode').onclick = async () => {
				if (!window.trainedNetwork) {
					alert('No trained network available. Train the network first.');
					console.log('âŒ No trained network found. Complete training first.');
					return;
				}
				
				console.log('=== ENABLING SMART AGENT MODE ===');
				console.log('Creating DQN behavior for agents...');
				
				try {
					// Import DQN behavior classes
					const { DQNAgentBehavior } = await import('./dqn_system.js');
					
					// Create DQN behavior instance
					const dqnBehavior = new DQNAgentBehavior();
					
					// Load the trained network into the behavior
					const weightData = { 
						weights: await window.trainedNetwork.getWeights(),
						stateSize: 14,
						actionSize: 4
					};
					
					if (dqnBehavior.loadTrainedWeights(weightData)) {
						dqnBehavior.enableSmartMode();
						
						// Set all agents to use DQN mode with the smart behavior
						window.gameManager.setAllAgentsMode('dqn', null, dqnBehavior);
						
						// Update UI
						if (modeSpan) modeSpan.textContent = 'DQN Smart Mode';
						if (statusSpan) statusSpan.textContent = 'Smart agents active';
						
						console.log('âœ… Smart agent mode enabled successfully!');
						console.log('Agents are now using the trained neural network for decisions');
						console.log('ðŸ’¡ Watch for:');
						console.log('   - Agents should glow blue (visual indicator)');
						console.log('   - More purposeful movement toward critical points');
						console.log('   - Smart decision counter should increase');
						console.log('   - Occasional debug messages in console');
						
						// Store globally for other functions
						window.dqnBehavior = dqnBehavior;
						
					} else {
						throw new Error('Failed to load trained weights into DQN behavior');
					}
					
				} catch (error) {
					console.error('âŒ Failed to enable DQN mode:', error);
					alert('Failed to enable DQN mode: ' + error.message);
				}
			};
			
			// Epsilon Slider - Control exploration rate
			document.getElementById('epsilon-slider').oninput = (event) => {
				const epsilonValue = parseInt(event.target.value) / 100; // Convert to 0-1 range
				document.getElementById('epsilon-value').textContent = `${event.target.value}%`;
				
				// Update DQN behavior if it exists
				if (window.dqnBehavior) {
					window.dqnBehavior.setExplorationRate(epsilonValue);
					console.log(`Exploration rate set to ${(epsilonValue * 100).toFixed(1)}%`);
				}
			};
				
				// Update smart decision counter for DQN mode
				setInterval(() => {
					try {
						if (window.dqnBehavior) {
							const behaviorStats = window.dqnBehavior.getStatus();
							const smartDecisionSpan = document.getElementById('smart-decisions');
							if (smartDecisionSpan && behaviorStats.smartStats) {
								let totalDecisions = 0;
								Object.values(behaviorStats.smartStats.agentStats || {}).forEach(agentStats => {
									totalDecisions += agentStats.decisions || 0;
								});
								smartDecisionSpan.textContent = totalDecisions;
							}
						}
					} catch (error) {
						console.warn('UI update error:', error);
					}
				}, 1000);
				
				console.log('DQN UI controls connected successfully');
			};
			
			setupControls();
		});
		
		console.log('DQN system initialized');
	</script>

	<script src="AgentTestMain.js" type="module" defer></script>
	</body>
</html>
